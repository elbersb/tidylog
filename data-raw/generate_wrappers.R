library(dplyr)
library(tidyr)
library(purrr)
library(glue)

source("data-raw/wrapper_mapping.R", local=TRUE)

# 1. Wrapper Generator
# ------------------------------------------------------------------------------
generate_wrapper <- function(full_fn_name, logger_name) {
    parts <- strsplit(full_fn_name, "::")[[1]]
    pkg   <- parts[1]
    fn    <- parts[2]

    orig_fn <- getExportedValue(pkg, fn)
    fmls    <- formals(orig_fn)

    # Construct arguments text using imap and pipe
    args_text <- imap_chr(fmls, function(val, name) {
        if (is.symbol(val) && as.character(val) == "") return(name)
        paste0(name, " = ", deparse1(val))
    }) |> paste(collapse = ", ")

    # 2. Define the Body Strings
    # ----------------------------------------------------------------------------
    # Use of log_join requires special handling because it takes .name_x and
    # .name_y arguments.
    if (logger_name == "log_join") {
        body <- glue("
            .call <- match.call(definition = {pkg}::{fn}, expand.dots = TRUE)
            .call[[1]] <- {logger_name}
            .call$.fun <- quote({pkg}::{fn})
            .call$.funname <- '{fn}'
            .call$.name_x <- deparse1(substitute(x))
            .call$.name_y <- deparse1(substitute(y))
            eval(.call, envir = parent.frame())"
        )
    }
    else {
        # Rename the first formals argument to .data so that the single-input
        # loggers (with first argument `.data`) can be used with any
        # single-input dplyr/tidyr function regardless of the first arg name.
        first_arg <- names(fmls)[1]
        body <- glue("
            .call <- match.call(definition = {pkg}::{fn}, expand.dots = TRUE)
            names(.call)[names(.call) == '{first_arg}'] <- '.data'
            .call[[1]] <- {logger_name}
            .call$.fun <- quote({pkg}::{fn})
            .call$.funname <- '{fn}'
            eval(.call, envir = parent.frame())"
        )
    }

    # 3. Final Assembly
    # ----------------------------------------------------------------------------
    # Account for default argument values that come from other packages
    generate_imports <- function(args_text) {
        tags <- c()

        if (grepl("deprecated\\(", args_text)) {
            # Even if used in dplyr, importing from lifecycle is more robust
            tags <- c(tags, "#' @importFrom lifecycle deprecated")
        }
        if (grepl("everything\\(", args_text)) {
            tags <- c(tags, "#' @importFrom tidyselect everything")
        }
        if (grepl("group_by_drop_default\\(", args_text)) {
            tags <- c(tags, "#' @importFrom dplyr group_by_drop_default")
        }

        if (length(tags) == 0) return("#'")
        return(paste(tags, collapse = "\n"))
    }

    import_tags <- generate_imports(args_text)


    # Note: Escape function braces with {{ }}
    glue("
#' Wrapper around {pkg}::{fn} that prints information about the operation.
#'
#' @description
#' Wrapper around [{pkg}::{fn}()] that prints information about the operation.
#'
#' @inherit {pkg}::{fn} return
#' @inheritParams {pkg}::{fn}
{import_tags}
#'
#' @seealso [{pkg}::{fn}()]
#'
#' @export
{fn} <- function({args_text}) {{
{formatted_body}
}}
",
         # Format the function body with tabs for readability.
         formatted_body = paste0("\t", gsub("\n", "\n\t", body)),
         .trim = FALSE)
}

# 4. Save to Disk
# ------------------------------------------------------------------------------
all_code <- imap(wrapper_mapping, function(fns, logger) {
    map_chr(fns, ~generate_wrapper(.x, logger))
}) |> unlist()

header <- paste0(
    "# Generated by data-raw/generate_wrappers.R: do not edit by hand\n",
    "# Generated at: ", Sys.time(), "\n\n"
)

# Account for the quoted name and value in pivot_wider.
globals_block <- "utils::globalVariables(c('name', 'value'))"

writeLines(c(header, all_code, globals_block), "R/generated_wrappers.R")

# 5. Update documentation
# ------------------------------------------------------------------------------
devtools::document()
